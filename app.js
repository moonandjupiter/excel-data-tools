(function () {
    "use strict";

    // IMPORTANT: This now points to your LOCAL computer.
    const BACKEND_URL = "http://localhost:8000/process-data";

    // Wait for the DOM to be loaded before initializing anything.
    document.addEventListener('DOMContentLoaded', initialize);

    function initialize() {
        // --- UI Initialization ---
        document.getElementById("tab-inserter").onclick = () => switchTab('inserter');
        document.getElementById("tab-cleanser").onclick = () => switchTab('cleanser');
        document.getElementById("tab-gemini").onclick = () => switchTab('gemini');
        
        document.getElementById("generate-rows").onclick = generateAndInsertRows;
        document.getElementById("cleanse-data").onclick = cleanseAndPasteData;
        document.getElementById("process-gemini").onclick = processWithGemini;
        document.getElementById("copy-gemini-result").onclick = copyGeminiResult;

        document.getElementById('rowCount').onfocus = function() { this.select(); };
        document.getElementById('rawData').onfocus = function() { this.select(); };
        document.getElementById('gemini-input').onfocus = function() { this.select(); };

        switchTab('inserter');

        // --- Office-Specific Initialization ---
        Office.onReady(function (info) {
            // Office host is ready.
        });
    }

    function switchTab(tabName) {
        // ... (This function remains unchanged)
    }

    async function generateAndInsertRows() {
        // ... (This function remains unchanged)
    }

    async function cleanseAndPasteData() {
       // ... (This function remains unchanged)
    }
    
    function copyGeminiResult() {
        // ... (This function remains unchanged)
    }

    async function processWithGemini() {
        const input = document.getElementById('gemini-input').value.trim();
        const status = document.getElementById('gemini-status');
        const button = document.getElementById('process-gemini');
        const outputContainer = document.getElementById('gemini-output-container');
        const outputTextarea = document.getElementById('gemini-output');

        outputContainer.style.display = 'none';
        outputTextarea.value = '';

        if (!input) {
            status.textContent = 'Please enter some data to process.';
            setTimeout(() => { status.textContent = ''; }, 3000);
            return;
        }

        button.disabled = true;
        status.textContent = 'Processing with Gemini...';

        try {
            const prompt = `
                You are a highly efficient data cleansing and expansion tool. Your task is to take a compressed or ranged string of data and expand it into a list where each line represents a single, complete item. The output should be plain text, with one item per line, and nothing else.
                Follow these rules strictly:
                1. Maintain the full prefix (the part of the string before the serial number, model, or item identifier).
                2. Expand ranges. For example, "10702P to 10704P" becomes three separate lines.
                3. Expand abbreviated serial numbers. For example, if the input is "HP DL380p Gen8 S#SGH438WACA,...WAC8", the second entry should be completed to "HP DL380p Gen8 S#SGH438WAC8".
                4. Handle complex formats where the description comes after the serial numbers, like "SN: 200108F & 200107F, Brand: Arrow...". Each output line must contain the full description.
                Input Data to process:
                ${input}
                Final Output:
            `;

            const payload = { "prompt": prompt };

            const response = await fetch(BACKEND_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Backend call failed: ${response.status}`);
            }

            const result = await response.json();
            const generatedText = result.cleansed_text;

            if (!generatedText || result.error) throw new Error(result.error || "No text generated by the model.");
            
            outputTextarea.value = generatedText;
            outputContainer.style.display = 'block';

            const cleansedData = generatedText.split('\n');

            await Excel.run(async (context) => {
                const sheet = context.workbook.worksheets.getActiveWorksheet();
                const selection = context.workbook.getSelectedRange();
                selection.load("rowIndex", "columnIndex");
                await context.sync();

                const dataToInsert = cleansedData.map(item => [item]);
                const targetRange = sheet.getRangeByIndexes(selection.rowIndex, selection.columnIndex, dataToInsert.length, 1);
                targetRange.values = dataToInsert;
                await context.sync();
                status.textContent = `Successfully pasted ${cleansedData.length} items.`;
            });

        } catch (error) {
            console.error(error);
            status.textContent = `Error: ${error.message}`;
        } finally {
            button.disabled = false;
            if (status.textContent.startsWith('Error')) {
                 setTimeout(() => { status.textContent = ''; }, 5000);
            }
        }
    }

    function parseData(rawData) {
        // ... (This function remains unchanged)
    }

})();

